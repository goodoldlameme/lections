# Лингвистические основы информатики

***

> *12.02.2019* 

##### Организационные вопросы

* Петрова Елена Александровна [elena.petrova@urfu.ru](mailto:elena.petrova@urfu.ru)

* Консультации: понедельник 16:10 КАДМ

##### Рекомендуемая литература

  - [Языки, грамматики, распознаватели](http://kadm.imkn.urfu.ru/files/shurzam.pdf) (Шур, Замятин) - основной учебник (много багов!)
  - Ахо, Лам, Сети, Ульман "Компиляторы. Принципы, технологии, инструменты" (Dragon book)
  - Ахо, Ульман "Теория синтаксического анализа, перевода и компиляции"
  - Cooper K. Engineering a Compiler.

> [репозиторий с .djvu книгами](https://github.com/afrolovskiy/compilers_labs/tree/master/literature)

– Чем будем заниматься? – Теорий компиляции.
Узнаем:

- Что такое язык;

- Что такое компилятор;

- Что делает компилятор с языком;

Будем в теории знать, как написать компилятор.

Немножко комментарием и истории: 

>Даже разбор формулы в экселе использует какие-то приёмы компиляции! 
>
>В 50-х годах людям надоело писать на ассемблере, и они начали думать. 
>
>К 60-м придумали. Дейкстра - двигатель прогресса, потому что придумал теорию, а не какое-то специфичное для задачи решение.

##### Что такое компилятор? 

По-простому – переводчик с языка на язык. Можно рассматривать как чёрный ящик с каким-то входом, выходом и магией внутри.

Принято разделять его работу на 2 фазы: 

***

&#8595; исходный текст

фронтенд: __анализ__ исходного текста. Если есть ошибки, то останавливаемся.

&#8595; промежуточное представление

бэкенд: __синтез__ – генерация программы, которая нам нужна вместе с какими-то оптимизациями.

&#8595; целевой код

***

Заниматься будем фронтендом!

##### Блок анализа

***

&#8595; исходный текст

лексический анализ: разбиваем текст на токены – знаки, переменные, идентификаторы.

&#8595; токены

синтаксический анализ(парсер)

&#8595; промежуточное представление 

***

##### Язык 

1. Лексика ~ слова

2. Синтаксис - правила построение предложений

3. Семантика

__Таблица символов__ – информация о переменных, константах, функциях. Используется на всех шагах анализа.

_Заполнение_: 

- лексика(?): встречаем новый символ – записываем имя переменной и записываем место первого появления.

- семантика: тип, место хранения, время объявления.

Написанию компилятора предшествует описание языка.

_Рассмотрим язык с условным оператором_:

Что есть условный оператор с точки зрения синтаксиса?  Опишем это с помощью __форм Бэкуса–Нуара__:

```
<условный оператор>::== if <логическое выражение> <список операторов> | else <список операторов>

<список операторов>::== <оператор>|<оператор>;<список операторов>

...

<идентификатор>::== [a-zA-Z]\w*
```

> **Обозначения**
>
> | {} — альтернатива
>
> <> — синтаксическая категория
>
> ::== — выводимость

**[Порождающая] грамматика** - объект математический. Основной способ описания синтаксиса и лексики (частный случай синтаксиса).

_Опр:_ __Грамматика__ – $G =:<\Sigma, \Gamma, P, S>$, где

- $\Sigma$ – терминальный алфавит (выходной);

- $\Gamma$ – нетерминальный алфавит (вспомогательный);

- $P$ – множество правил вывода;

- $S \in \Gamma$ – выделенный нетерминал – аксиома (одна).

_**Соглашения**_

- $a, b, c, :…$ – терминальные состояния (if - терминал);
- $x, y, z, :…$ – цепочки (слова) терминалов;
- $A, B, C, :…$ – нетерминалы;
- $X, Y, Z, :…$ – что угодно;
- $\alpha, \beta, \gamma, :...$ – произвольные цепочки (терминальные или нетерминальные);
- $\lambda$ – пустое слово.

_**Выводимость**_ 

**Правило вывода:**  $(\alpha \rightarrow \beta)$ $\alpha;\beta \in (\Sigma \cup\Gamma)^*$, более конкретно $\alpha \in (\Sigma\cup\Gamma)^*\Gamma(\Sigma\cup\Gamma)^*$ - т.е в $\alpha$ должен быть хотя бы один элемент из не терминального состояния.

Основная функция этого правила – порождение языка.

_Опр:_ Цепочка $\gamma$ **непосредственно выводима** из цепочки $\sigma$, если $\gamma = \delta_1\beta \delta _2$, $\sigma = \delta _1 \alpha \delta _2$ и $(\alpha \rightarrow \beta) \in P$.

Обозначается как $\sigma \Rightarrow \gamma$.

> В цепочке сигма есть подпоследовательность альфа, которую можно заменить на бету. Выводимость - отношение на множестве цепочек. Рефлексивно-транзитивное замыкание $\sigma \Rightarrow \gamma.$ Возможность вывести одну цепочку из другой за некоторое число шагов.

_Опр:_ $\gamma$ **выводима** из $\sigma$ если существует последовательность цепочек $\eta_0, ..., \eta_n, n \ge 0$ такая, что $\eta _0 = \sigma, \eta _n = \gamma, \eta _{i-1} \Rightarrow \eta _i$ $ (\sigma \Rightarrow ^*\gamma)$.

Последовательность $\eta_0, ..., \eta_n$ – **вывод**.

Получается, что грамматика для нас — просто набор правил вывода. Потому что всё остальное мы зафиксировали в обозначениях.

_Опр:_ **Язык**, порождённый грамматикой $G = :<\Sigma, \Gamma, P, S>$ : ${w \in \Sigma^*|S \Rightarrow ^*w}$ — множество терминальных цепочек таких, что их можно вывести из аксиомы.

_Опр:_ $\eta_0, ..., \eta_n: \eta_0=s, \eta_n=w, \eta _{i-1} \Rightarrow \eta _i$, $\eta_i$ – форма (шаг).

_**Пример**_:

${a^n b^n | n \in \N_0}$ — Что это? Язык?

_Правила:_

- $S \rightarrow aSb$
- $S \rightarrow \lambda$

Рассмотрим вывод терминальной цепочки:

$S \Rightarrow aSb \Rightarrow aaSbb \Rightarrow aabb$

> $ab$ - терминалы (см. соглашения)

_**Ещё пример**_

$S \rightarrow ABS|\lambda$	$S \rightarrow SS|a|b|\lambda$

$AB \rightarrow BA​$

$A \rightarrow a​$

$B \rightarrow b$

$S \Rightarrow ABS \Rightarrow ABABS \Rightarrow ^* (AB)^nS \Rightarrow (AB)^n$

Можем перейти к терминалам

$S \Rightarrow ^*ABABAB \Rightarrow ABBAAB \Rightarrow abbaab$

Хотим загнать буквы А в конец, а B в начало. Будем менять местами буквы по второму правилу.

$ABABAB \Rightarrow BA_AB_AB \Rightarrow B_AB_AAB \Rightarrow BBAA_AB_ \Rightarrow :...$

# 