# Лингвистические основы информатики

***

> *12.02.2019* 

## Организационные вопросы

* Петрова Елена Александровна [elena.petrova@urfu.ru](mailto:elena.petrova@urfu.ru)

* Консультации: понедельник 16:10 КАДМ
## Рекомендуемая литература

  - [Языки, грамматики, распознаватели](http://kadm.imkn.urfu.ru/files/shurzam.pdf) (Шур, Замятин) - основной учебник (много багов!)
  - Ахо, Лам, Сети, Ульман "Компиляторы. Принципы, технологии, инструменты" (Dragon book)
  - Ахо, Ульман "Теория синтаксического анализа, перевода и компиляции"
  - Cooper K. Engineering a Compiler.

> [репозиторий с .djvu книгами](https://github.com/afrolovskiy/compilers_labs/tree/master/literature)

– Чем будем заниматься? – Теорий компиляции.
Узнаем:

- Что такое язык;

- Что такое компилятор;

- Что делает компилятор с языком;

Будем в теории знать, как написать компилятор.

Немножко комментарием и истории: 

>Даже разбор формулы в экселе использует какие-то приёмы компиляции! 
>
>В 50-х годах людям надоело писать на ассемблере, и они начали думать. 
>
>К 60-м придумали. Дейкстра - двигатель прогресса, потому что придумал теорию, а не какое-то специфичное для задачи решение.

## Что такое компилятор? 

По-простому – переводчик с языка на язык. Можно рассматривать как чёрный ящик с каким-то входом, выходом и магией внутри.

Принято разделять его работу на 2 фазы: 

***

&#8595; исходный текст

фронтенд: __анализ__ исходного текста. Если есть ошибки, то останавливаемся.

&#8595; промежуточное представление

бэкенд: __синтез__ – генерация программы, которая нам нужна вместе с какими-то оптимизациями.

&#8595; целевой код

***

Заниматься будем фронтендом!

**Блок анализа**

***

&#8595; исходный текст

лексический анализ: разбиваем текст на токены – знаки, переменные, идентификаторы.

&#8595; токены

синтаксический анализ(парсер)

&#8595; промежуточное представление 

***

## Язык 

1. Лексика ~ слова

2. Синтаксис - правила построение предложений

3. Семантика

__Таблица символов__ – информация о переменных, константах, функциях. Используется на всех шагах анализа.

_Заполнение_: 

- лексика(?): встречаем новый символ – записываем имя переменной и записываем место первого появления.

- семантика: тип, место хранения, время объявления.

Написанию компилятора предшествует описание языка.

_Рассмотрим язык с условным оператором_:

Что есть условный оператор с точки зрения синтаксиса?  Опишем это с помощью __форм Бэкуса–Нуара__:

```
<условный оператор>::== if <логическое выражение> <список операторов> | else <список операторов>

<список операторов>::== <оператор>|<оператор>;<список операторов>

...

<идентификатор>::== [a-zA-Z]\w*
```

> **Обозначения**
>
> | {} — альтернатива
>
> <> — синтаксическая категория
>
> ::== — выводимость

**[Порождающая] грамматика** - объект математический. Основной способ описания синтаксиса и лексики (частный случай синтаксиса).

_**Опр:**_ __Грамматика__ – $G =:<\Sigma, \Gamma, P, S>$, где

- $\Sigma$ – терминальный алфавит (выходной);

- $\Gamma$ – нетерминальный алфавит (вспомогательный);

- $P$ – множество правил вывода;

- $S \in \Gamma$ – выделенный нетерминал – аксиома (одна).

_**Соглашения**_

- $a, b, c, :…$ – терминальные состояния (if - терминал);
- $x, y, z, :…$ – цепочки (слова) терминалов;
- $A, B, C, :…$ – нетерминалы;
- $X, Y, Z, :…$ – что угодно;
- $\alpha, \beta, \gamma, :...$ – произвольные цепочки (терминальные или нетерминальные);
- $\lambda$ – пустое слово.

_**Выводимость**_ 

**Правило вывода:**  $(\alpha \rightarrow \beta)$ $\alpha;\beta \in (\Sigma \cup\Gamma)^*$, более конкретно $\alpha \in (\Sigma\cup\Gamma)^*\Gamma(\Sigma\cup\Gamma)^*$ - т.е в $\alpha$ должен быть хотя бы один элемент из не терминального состояния.

Основная функция этого правила – порождение языка.

_**Опр:**_ Цепочка $\gamma$ **непосредственно выводима** из цепочки $\sigma$, если $\gamma = \delta_1\beta \delta _2$, $\sigma = \delta _1 \alpha \delta _2$ и $(\alpha \rightarrow \beta) \in P$.

Обозначается как $\sigma \Rightarrow \gamma$.

> В цепочке сигма есть подпоследовательность альфа, которую можно заменить на бету. Выводимость - отношение на множестве цепочек. Рефлексивно-транзитивное замыкание $\sigma \Rightarrow \gamma.$ Возможность вывести одну цепочку из другой за некоторое число шагов.

_**Опр**:_ $\gamma$ **выводима** из $\sigma$ если существует последовательность цепочек $\eta_0, ..., \eta_n, n \ge 0$ такая, что $\eta _0 = \sigma, \eta _n = \gamma, \eta _{i-1} \Rightarrow \eta _i$ $ (\sigma \Rightarrow ^*\gamma)$.

Последовательность $\eta_0, ..., \eta_n$ – **вывод**.

Получается, что грамматика для нас — просто набор правил вывода. Потому что всё остальное мы зафиксировали в обозначениях.

_**Опр:**_ **Язык**, порождённый грамматикой $G = :<\Sigma, \Gamma, P, S>$ : ${w \in \Sigma^*|S \Rightarrow ^*w}$ — множество терминальных цепочек таких, что их можно вывести из аксиомы.

_Опр:_ $\eta_0, ..., \eta_n: \eta_0=s, \eta_n=w, \eta _{i-1} \Rightarrow \eta _i$, $\eta_i$ – форма (шаг).

_**Пример**_:

${a^n b^n | n \in \N_0}$ — Что это? Язык?

_Правила:_

- $S \rightarrow aSb$
- $S \rightarrow \lambda$

Рассмотрим вывод терминальной цепочки:

$S \Rightarrow aSb \Rightarrow aaSbb \Rightarrow aabb$

> $ab$ - терминалы (см. соглашения)

_**Ещё пример**_

$S \rightarrow ABS|\lambda$	$S \rightarrow SS|a|b|\lambda$

$AB \rightarrow BA$

$A \rightarrow a$

$B \rightarrow b$

$S \Rightarrow ABS \Rightarrow ABABS \Rightarrow ^* (AB)^nS \Rightarrow (AB)^n$

Можем перейти к терминалам

$S \Rightarrow ^*ABABAB \Rightarrow ABBAAB \Rightarrow abbaab$

Хотим загнать буквы А в конец, а B в начало. Будем менять местами буквы по второму правилу.

$ABABAB \Rightarrow BAABAB \Rightarrow BABAAB \Rightarrow BBAAAB \Rightarrow :...$

# 

> *19.02.2019*

```
pos = init + rate * 60;

// после лескического анализа превращается в...
id,15 <=> <id,2><+><id,3><*><const><;>
// cинтаксическому анализу всё равно, как называется переменная

// после ситанксического анализа превращается в...
    =
   / \
id,1   +
      / \
   id,2  *
        / \
     id,3 const
//после семантического добавятся какие-то атрибуты
```

На каждой стадии – новый язык. Значит, нужны новые способы порождения\описания. А этот способ порождает распознаватель.

## Иерархия Хомского-Шютценберже

|      | Вид грамматики         | Распознаватель                                         | Класс языков            |
| ---- | ---------------------- | ------------------------------------------------------ | ----------------------- |
| 0    | Грамматика общего вида | МТ                                                     | Рекурсивно перечислимые |
| 1    | Контекстно-зависимые   | МТ с линейно ограниченной памятью (LBA)                | КЗЯ                     |
| 2    | Контекстно-свободные   | Недетерминированный автомат с магазинной памятью (PDA) | КСЯ                     |
| 3    | Праволинейные          | ДКА                                                    | Регулярные языки        |

Опр. Контекстно-зависимая грамматика — все правила имеют вид $\alpha A\gamma \rightarrow \alpha \beta\gamma$ (у терминала имеется контекст, который сохраняется при его раскрытии) .

***Опр.*** Язык обладает свойством $P$, если $\exists$ грамматика со свойством $P$, его порождающая.

***Опр.*** Контекстно-свободная грамматика — все правила имеют вид $A \rightarrow \beta$ (частный случай КЗГ, когда оба контекста пусты)

***Опр.*** Праволинейные грамматики — все правила имеют вид $A \rightarrow aB$ или $A \rightarrow\lambda $ справа либо лямбда, либо терминал+нетерминал

Вспомним пример. Кажется, что это грамматика обычного вида.

$S \rightarrow ABS|\lambda$	$S \rightarrow SS|a|b|\lambda$

$AB \rightarrow BA$

$A \rightarrow a$

$B \rightarrow b$

Построим КСГ, которая породит язык выше. Порождаем цепочки, где букв B на одну больше, чем a/

Из А должны выводиться строчки, где на одну a больше

$S \rightarrow aB|bA$

$A \rightarrow aS|bAA$

$B\rightarrow bS|aBB$

$A \rightarrow a$

$B \rightarrow b$

$abba : :S \rightarrow aB \rightarrow abS \rightarrow abbA \rightarrow abba $

Иерархия: регулярные $\subset$ КСЯ $\subset$ КЗЯ $\subset$ Rec $\subset$ RecEn[^2].

## Контекстно-свободные грамматики и языки

***Опр.*** Упорядоченное дерево — дерево с заданным линейным порядком со следующими свойствами:

1. Если $x$ - сын узла $y$, то $x \ge y$
2. Если $x \le y$ и они братья, то для всех сыновей $z$ узла $x$: $z\le y$

> Порядок, возникающий при обходе в глубину слева направо

**Пример**:

$S \rightarrow SS|(s)|\lambda$

$(( ))$ 

$S \rightarrow SS \rightarrow (s) \rightarrow ((s)) \rightarrow (())$

```
           S₁
         /   \
        S₂    S₄
	    |	 / | \
        λ₃ (₅  s₆  )₁₁
             / | \
          (₇   s₈  )₁₀
               |
               λ₉
```

***Опр***. Дерево вывода цепочки $\omega$ в $G =:<\Sigma, \Gamma, P, S>$ — упорядоченное дерево со следующими свойствами:

1. Узлы – нетерминалы, корень – аксиома, листья – терминалы или $\lambda$, причём у листьев, помеченных пустым словом нет братьев.

   > Если есть братья, то $\lambda a == a$

2. Если у узла $x$ все сыновья это некоторый набор $y_1, : … : y_n$, таких, что $y_1 \le : ...: \le y_n$, и узлы $x$, $y_1, : … : y_n$ помечены символами $X, Y_1, : … : Y_n$, то $(X \rightarrow Y_1, : … : Y_n) \in P$.

   > Применили правило, в дереве появился куст вывода

3. Если все листья дерева имеют метки $a_1 \le a_2 \le : … \le : a_n$, то $\omega = a_1…a_n$

***Опр.*** Вывод цепочки $\omega (S \Rightarrow \alpha_1 \Rightarrow : … : \Rightarrow \alpha_n=\omega)$ в $G =:<\Sigma, \Gamma, P, S>$ представлен деревом вывода $T$, если $\exists$ набор стандартных поддеревьев $T_1, … T_n$ таких, что на упорядоченных листьях дерева $T_i $ написана форма $\alpha_i$.

***Опр.*** Стандартное поддерево $T' $дерева $T$, если:

1. корень $T'$ - корень $T$

2. Если узел $x$ дерева $T$$ \in T'$, то либо $x$ - лист, либо все сыновья $x$ в $T$ $\in T'$

   > Если с узлом лежит хотя бы один его сын, то и все его сыновья тоже лежат.

**Пример по последнему языку:**

![standard_subtrees](.\pics\standard_subtrees.jpg)

Наша любимая грамматика, которая порождает арифметику:

$E \rightarrow E+E|E*E|(E)|x$

$x+x*x$

```
   E
  /|\
E  +  E   - этот куст можно передвинуть влево, получится два разных дерева
|    /|\    для одного и того же. Плохо.
x   E * E
    |   |
    x   x
```

***Опр.*** Грамматика однозначна, если $\forall \omega$, выводимой в грамматике, $\exists!$ дерево вывода.

Следующая грамматика однозначна и эквивалентна предыдущей

$E \rightarrow E + T|T$

$T \rightarrow T*F|F$

$F \rightarrow (E) |x$

1. Правосторонний вывод и r-формы:$E \rightarrow E + T \rightarrow E+T*F \rightarrow E+T*x \rightarrow E+F*x \rightarrow E+x*x\rightarrow T+x*x \rightarrow F+x*x \rightarrow x+x*x$
2. Левосторонний вывод и l-формы:$E \rightarrow E+T\rightarrow T+T \rightarrow F+T \rightarrow x+T \rightarrow x+T*F \rightarrow x+F*F \rightarrow x+x*F\rightarrow x+x*x $

Плата за однозначность - увеличение длины вывода

> 26.02.2019 

## Праволинейная грамматика
| A $\rightarrow \alpha B$ | A $\rightarrow \alpha B$ |
| ------------------------ | :----------------------- |
| A $\rightarrow \lambda$  | A $\rightarrow$ $\alpha$ |

_**Теорема**_

Праволинейная грамматика порождает регулярный язык

_Д-во:_

​	$G = (\Sigma, \Gamma, P, S)$

​	$KA = (\Sigma, \Gamma, \delta, S, F)$

​	$F = {A \in \Gamma | (A \rightarrow \lambda) \in P}$

​	$\delta(A, a) = B <=> (A \rightarrow aB) \in P$

​	A <-a-> B

​	$w = a_1... a_n$

​	$S \rightarrow a_1A_1 \rightarrow a_1a_2A_2 \rightarrow  ...\rightarrow a_1...a_nA_, \rightarrow a_1...a_n$

_Строим автомат по рег. выр-ю_

a(b+cc)*

<svg width="400" height="150" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<ellipse stroke="black" stroke-width="1" fill="none" cx="118.5" cy="88.5" rx="30" ry="30"/>
	<text x="112.5" y="94.5" font-family="Times New Roman" font-size="20">S</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="223.5" cy="100.5" rx="30" ry="30"/>
	<text x="216.5" y="106.5" font-family="Times New Roman" font-size="20">A</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="337.5" cy="88.5" rx="30" ry="30"/>
	<text x="330.5" y="94.5" font-family="Times New Roman" font-size="20">B</text>
	<path stroke="black" stroke-width="1" fill="none" d="M 213.439,72.362 A 22.5,22.5 0 1 1 239.714,75.398"/>
	<text x="228.5" y="23.5" font-family="Times New Roman" font-size="20">b</text>
	<polygon fill="black" stroke-width="1" points="239.714,75.398 248.809,72.893 241.448,66.125"/>
	<polygon stroke="black" stroke-width="1" points="148.306,91.906 193.694,97.094"/>
	<polygon fill="black" stroke-width="1" points="193.694,97.094 186.313,91.218 185.178,101.153"/>
	<text x="164.5" y="116.5" font-family="Times New Roman" font-size="20">a</text>
	<polygon stroke="black" stroke-width="1" points="253.335,97.359 307.665,91.641"/>
	<polygon fill="black" stroke-width="1" points="307.665,91.641 299.185,87.505 300.232,97.451"/>
	<text x="278.5" y="116.5" font-family="Times New Roman" font-size="20">c</text>
	<polygon stroke="black" stroke-width="1" points="307.665,91.641 253.335,97.359"/>
	<polygon fill="black" stroke-width="1" points="253.335,97.359 261.815,101.495 260.768,91.549"/>
	<text x="274.5" y="84.5" font-family="Times New Roman" font-size="20">c</text>
</svg>

$S \rightarrow aA$

$A \rightarrow bA|cB|\lambda$

$B \rightarrow cA$

### Преобразования грамматик 

Грамматики эквивалентные, если они порождают один и тот же язык.

#### Приведенные грамматики

_**Опр**:_ Нетерминал A $\in \Gamma$ - производящий, если из него можно получить производящую цепочку $A \Rightarrow _G^* u^- $

_**Опр**:_ A $\in \Gamma$ - достижимый, если  $A \Rightarrow _G^* \alpha A\beta $

_**Опр:**_ Грамматика приведенная, если все ее нетерминалы достижимые и производящие

***Примеры***

$S \rightarrow bAc | AcB$

$A \rightarrow abC$

$B \rightarrow Ea$

$C \rightarrow BD$

$D \rightarrow CCa$

$E \rightarrow Fbb$

$F \rightarrow a$

$\Gamma_p$ = {F, E, B} - производящие 

$\Gamma_r$ = {S, A, B, C, E, D, F} - достижимые

Нахождение $\Gamma_r: \Gamma_r \rightarrow S$ -> ~~S~~, A, B -> ~~S~~, ~~A~~, B, C, E -> ~~S~~, ~~A~~, ~~B~~, C, E, D -> ~~S~~, ~~A~~, ~~B~~, ~~C~~, E, D, F

$\Gamma_r^n = \Gamma_r^{n-1} \cup \{A | (B \rightarrow \alpha A\beta) \in P, B \in \Gamma_r^{n-1}\}$ - n-й шаг

добавляем нетерминалы из правой части

$\Gamma_p: $ все нетерминалы, из которых вывод цепочки за 1 шаг

$\Gamma_p^{n} = \Gamma_p^{n-1} \cup \{A | (A \rightarrow \gamma) \in P, \gamma \in (\Sigma \cup \Gamma_p^{n-1})\}$

**Теорема**
Для любой КСГ G существует эквивалентная ей приведенная грамматика
_**Д-во**:_ 
	КСГ G = ($\Sigma, \Gamma, P, S$)
	Находим $\Gamma_p$
	Если S $\notin \Gamma_p, то G' = (\Sigma, \emptyset, \emptyset, \emptyset)$
	Иначе $\widetilde{G} = (\Sigma, \Gamma_p, \widetilde{P}, S)$
	$\widetilde{P} = \{(A \rightarrow \gamma) \in P |A,\gamma \in (\Sigma \cup \Gamma_p)^*\}$

​	Находим $(\Gamma_p)_r$

​	$G' = (\Sigma, (\Gamma_p)_r, P', S)$

​	P' = {$(A \rightarrow \gamma) \in \widetilde{P}| A, \gamma \in (\Sigma \cup (\Gamma_p)|r)^*$}

​	$(\Gamma_p)_p - достижимы\ в\ \widetilde{G}, G', производящие\ в\ \widetilde{G}, G'$

​	$A \in (\Gamma_p)_r$

​	$S {\Rightarrow}_{\widetilde{G}}^* \lambda AB \Rightarrow_{\widetilde{G'}}^* uwv $

**_Пример_**

S $\rightarrow$ ab|bAC

A $\rightarrow$ CB

B $\rightarrow$ aSA

C $\rightarrow$ bC|d

1) производящие $\rightarrow$ достижимые 

​	$\Gamma_p = \{C, S\}; (\Gamma_p)_r = \{S\}; [G': S \rightarrow ab]$

2) достижимые $\rightarrow$ производящие

​	$\Gamma_p = \{S, A, B, C\}; (\Gamma_p)_r = \{C, S\}; [G': S \rightarrow ab; C \rightarrow d ]$

#### $\lambda$ - свободные грамматики 

_**Опр:**_ $A \in \Gamma - аннулирующий, если A => ^* \lambda$

_**Опр:**_ $Ann(G)$ - мн-во аннулирующих нетерминалов.

Нахождение аннулирующий символов

$Ann^1(G) = \{A \in \Gamma | (A \rightarrow \lambda) \in P\}$

$Ann^n(G) = Ann^{n-1}(G) \cup \{A \in \Gamma | (A \rightarrow \gamma ) \in P, \gamma \in (Ann^{n-1}(G))^*\}$

_**Пример**_

​	S $\rightarrow$ aBC|AE

​	A $\rightarrow$ bC| $\lambda$

​	B $\rightarrow$ ACA

​	C $\rightarrow \lambda$

​	E $\rightarrow$ CA

​	D $\rightarrow$ bE|c

$Ann(G)$:

1. {A,C}
2. {A,C, B, E}
3. {A, B, C, E, S}

_**Опр**:_ $\lambda$ - свободная грамматика - грамматика, которая либо не содержит аннулирующих правил вида $(A \rightarrow \lambda)$, либо содержит единств. такое правило S $\rightarrow \lambda$ и S не встреч-ся в правых частях правил вывода.

__Теорема__ Любая грамматика эквивалентна некоторой $\lambda$ -свободной грамматике 

_**Д-во:**_

​	$G = (\Sigma, \Gamma, P, S) - исх., G' = (\Sigma, \Gamma', P', S') - \lambda\ свободная $

0. Если $\lambda \in L(G), то\  \Gamma' = \Gamma \cup S', P' = P \cup \{(S' \rightarrow \lambda), (S' \rightarrow S)\}$

​	Иначе $\Gamma = \Gamma'$, S = S', P = P'

1. Построить Ann(G)

   1.5 в $\Gamma'$ = \{A | ($A \rightarrow \gamma) \in P, \gamma \neq \lambda$\}

2. $\beta \preccurlyeq \gamma$, если $\beta$ - подпосл-ть $\gamma$ и все символы $\gamma$, которых нет в $\beta$, аннулирующие.

   P' = $\{(A \rightarrow \beta) | (A \rightarrow \gamma) \in P, \beta \preccurlyeq \gamma, \beta \neq \lambda\}$
   
   > Взяли все исходные правила. В новую грамматику положили их "части"-подстроки, в которых либо присутствует, либо удалён каждый из аннулирующих нетерминалов.
3. L(G) = L(G')
   
   1. w $\in$ L(G')
      $S \Rightarrow_{G'} \alpha_i  \Rightarrow_{G'}...  \Rightarrow_{G'} \alpha_n = w$
      
      $\alpha_{i} \Rightarrow_{G'} \alpha_{i+1}(A \rightarrow \beta) \in P' $, значит, в $G$ $\exists (A \rightarrow \gamma) \in P, \beta  \preceq \gamma$.
      
      Тогда $\gamma \Rightarrow^*_G \beta$, следовательно, $A \Rightarrow^*_G \beta$, и это верно для любых цепочек.
      
   2. $w \in L(G)$	

**_Пример_**

Отрезаем поддеревья с $\lambda$ на конце. Предок этого поддерева имеет сыновей с непустыми на конце цепочками.

 ![1551174632263](.\pics\1551174632263.png)



**_Пример_**
 $S \rightarrow ~~abc~~|aB|~~aC~~|a|A|E|AE$

 $S' \rightarrow S|\lambda$

$A \rightarrow \cancel{bc}|b; B \rightarrow \cancel{ACA}|\cancel{AC}|AA|\cancel{CA}|A|\cancel{C}$

$E \rightarrow A; D \rightarrow bE|b|c$

> 05.03.2019

### Нормальная форма Хомского(ХНФ)

($\lambda$-свободная)Грамматика находится в сокращенной форме Хомского, если все ее не аннулирующие правила вывода имеют вид:

A $\rightarrow$ BC

A $\rightarrow$ a

_**Теорема:**_

​	Любая грамматика эквивалентна некоторой грамматике в ХНФ.

_**Д-во:**_ 

​	$G = (\Sigma, \Gamma, P, S) - \lambda-свободна$

1. $\forall A \rightarrow  X_1, ... ,X_n, n \ge 2$(хотя бы 2 символа)

   если $X_i \in \Sigma$, то добавить новый нетерминал $X'_i$, новое правило $X'_i \rightarrow X_i$ и все вхождения $X_i$ в правые части правил, длина которых $\ge 2$ заменить на $X'_i$

   _Пример_

   $A \rightarrow aBc$

   $A' \rightarrow a$

   $A \rightarrow A'Bc$

   $C' \rightarrow c$

   $A \rightarrow A'BC'$

2. $A \rightarrow B$ что с ним делать? (выводится нетерминал из нетерминала)

    Заменим правую часть на всё, что выводится из $B$. Но что, если есть цепочка $A \rightarrow B  \rightarrow  …  \rightarrow  A$ (цикл)? Сначала нужно от них избавиться.

_**Опр**_: Грамматика циклическая если $\exists A \in \Gamma: A =>^+ A.$

​	Ацикличная в противном случае.

_**Лемма**_: 

​	Любая грамматика эквивалентна некоторой цикличной грамматике.

***Д-во:***	

​	Пусть $A_1 \Rightarrow A_2  \Rightarrow …  \Rightarrow A_n  \Rightarrow A_1$

> Мы рассматриваем только цепные правила, так как грамматика $\lambda$-свободная, то есть не возникнет ситуации $A \rightarrow BC \rightarrow AC \rightarrow A$ (если из $C$ выводится $\lambda$)

​	заменим все $A_i$ на A и удалим правила вида A $\Rightarrow$ A

​	Почему это работает? 

​	$G = (\Sigma, \Gamma, P, S)$ - цикличная

​	$G' = (\Sigma, \Gamma, P, S)$ которая получилась

​	Почему они эквивалентны?

​	$\Rightarrow$ одна выводится из другой, потому что вывод в G' получается стиранием индексов у $A_i$

​	$\Leftarrow$ Есть вывод в G', как получить в G

​	Возьмем какой-то вывод G'

​	пусть A участвовал в выводе $\Rightarrow$ такое вот выполнялось

​	B → $\alpha A \beta$ - применялось в выводе w

​	значит применялось обязательно A → $\gamma$    

​	$\Downarrow$

​	Чтобы в G $(B \rightarrow \alpha A_i \beta), (A_j \rightarrow \gamma) \in$ P надо $A_i \Rightarrow _G^* A_j$

​	Если ациклическая, то заменять пока не дойдем до терминальных цепочек

​	заменять на правые, пока не примут вид A → $\alpha$ или A → $B_1...B_n$

​	Теперь берем получившиеся нетерминалы.

​	Eсли их там больше 2, то нас это не устраивает.

3. $\forall A → B_1B_2 ... B_n , n\ge 3$

   замена 

   $A → B_1B'_2$

   $B'_2 → B_2.. B_n => B'_2 → B_2 B'_3$

   $B'_3 → b_3.. B_n$

   ...

   $B'_{n-1}$

   После этого правила примут нужный нам вид

   ***Пример***

   ​	S → AB|aAB

   ​	A → bB|aBC|$\lambda$

   ​	B → AS|bA|a

   ​	C → b

   ​	Приводим в $\lambda$-свободную грамматику.

   > Ann(G) = {A}

   ​	S → AB|B|<u>aAB</u>|<u>ab</u>

   ​	A → <u>bB|aBC</u>

   ​	B → AS|S|<u>bA</u>|b|a

   ​	C → b

   ​	Приведем к ХНФ.

   > A' → a
>
   > B' → b

   ​	S → AB|B|<u>A'AB</u>|<u>A'B'</u>

   ​	A → <u>B'B|A'BC</u>

   ​	B → AS|S|<u>B'A</u>|b|a

   ​	C → b

   ​	Ищем циклы

   > S → B
>
   > B → S

***

   ​	S → AS|<u>A'AB</u>|A'B'|B'A|b|a

   ​	A → B'S|<u>A'SC</u>

   ​	C → b

   ​	A' → a

   ​	B' → b

***

   ​	S → AS|<u>A'D</u>|A'B'|B'A|b|a

   ​	A → B'S|<u>A'E</u>

   ​	E → SC

   ​	D → AB'

   ​	C → b

   ​	A' → a

   ​	B' → b

***

   ### Свойства КСЯ

   Помеченная позиция - от балды выбираем позиции, но они должны быть разные

   _**Лемма Огдена**_ 

   (прокачанная лемма о накачке :D)

   Пусть L - КСЯ. Тогда $\exists m \in \mathbb{N}: \forall w \in L$, в которых помечено не менее  m позиций, представимо в виде произведения слов $w = uxzyv:$ 

   ​	1) $xy$ содержит хотя бы одну помеченную позицию

   ​	2) $xzy$ содержит не более $m$ помеченных позиций

   ​	3) $u x^n z y^n v \in L\ \forall n \in \mathbb{N_0}$

   _Д-во:_

   > Пусть L порождается грамматикой в ХНФ.
   >
   > G = ($\Sigma, \Gamma$, P, S) ; L = L(G)
   >
   > m = $2^{|\Gamma| + 1}$
   >
   > Расcсмотрим w слово из L |w| $\ge$ m и пометим не менее m позиций.
   >
   > Рассм его дерево вывода
   >
   > ![photo_2019-03-11_15-38-43](.\pics\photo_2019-03-11_15-38-43.jpg)
   >
   > *<u>b - точки ветвления</u>* 
   >
   > Построим путь $p_w$ в дереве вывода слова w в G.
   >
   > корень S $\in p_w$
   >
   > из двух потомков (потому что в ХНФ) узла, который уже $\in p_w$ выбираем того, из которого выводится больше помеченных позиций.

   _**Опр:**_ Точки ветвления - узел, у которого из обоих потомков выводятся подслова w с помеченными позициями.

   > (*) Каждая точка ветвления порождает не менее половины помеченных позиций от тех, что порождает предыдущая точка ветвления.
   >
   > В $p_w$ не менее |$\Gamma$| + 1 т.в.
   >
   > Среди всех точек ветвления в $p_w$ рассмотрим последние |$\Gamma$| + 1 точки =>
   >
   > => хотя бы 2 узла имеют одинаковую метку.
   >
   > Пусть это будет A 
   >
   > ![photo_2019-03-11_15-38-42](.\pics\photo_2019-03-11_15-38-42.jpg)
   >
   > $v_1$ и $v_2$ точки ветвления
   >
   > A =>^+^ z
   >
   > A =>^+^ xzy
   >
   > A =>^+^ xAy
   >
   > Почему вып. лемма:
   >
   > 1) v_1 - точка ветвления => x или y содержат хотя бы одну помеченную позицию
   >
   > 2) В xzy не более m помеченных позиций по (*)
   >
   > 3) S =>^+^ uAv =>^+ uxAyv => ux^2^ A y^2^v => ...

Используется, чтобы опровергнуть КС

_**Пример**_

Грамматика в ХНФ

S -> AB

A -> AB|a

B -> BS|b

![photo_2019-03-11_15-38-41](.\pics\photo_2019-03-11_15-38-41.jpg)

> 12.03.19.

### Лемма о накачке (Следствие теоремы Огдена)

L - КСЯ $\Rightarrow \exists n, m \in \mathbb{N}: \forall w \in L: |w| \ge n$ w представимо как uxzyv

причем: 

1) xy $\neq \lambda$

2) |xzy| $\le$ m

3) $ux^k zy^kv \in L\ \forall k \in \mathbb{N_0}$

Вариант леммы Огдена, когда все позиции являются выделенными. 

#### Следствия леммы о накачке

На экзамене на этот вопрос не надо доказывать лемму о накачке

и следствия не как в книжке 

1. Язык {$a^n b^n c^n| n \in \mathbb{N}$} - не КСЯ

(лемма - проверка на то, что язык контекстно свободный)

_Д-во:_

> о/п 
>
> L - КСЯ $\Rightarrow$ вып-ся лемма о накачке
>
> $a^l b^l c^l , l \ge m 3l \ge n$
>
> a..a..ab...b...bc...c..c
>
> блок - подслово из одинаковых букв
>
> xzy расп-но в одном блоке, либо на границе двух
>
> 1) б.о.о. xyz в аааааа
>
> будет ''накачиваться'' одна буква
>
> получится слово не из языка $(a^{l+r} b^l c^)$
>
> 2) б.о.о. xyz на границе $a^l b^l$
>
> если на границе x или y - чередование нарушается
>
> а если на границе z, то a и b накачиваются, а с нет
>
> противоречие 

2. Язык L = {$ww|w \in \Sigma^*, |\Sigma| \ge$ 2} - не КСЯ

   _Д-во_

   > $\Sigma = \{a_1, ..., a_{n'}\}$
   >
   > для любого слова должно накачиваться => и для такого должно
   >
   > $a_1^l a_2^l ... a_k^l a_1^l a_2^l ... a_k^l , k \le n'$
   >
   > $l \ge m;\ 2|w| \ge n$
   >
   > Накачка может происходить двумя способами: одну из половин и когда границу
   >
   > 1) накачиваем вторую половину
   >
   > По предположению представимо $w^2 = uxzyv$
   >
   > $ux^2 zy^2 v$
   >
   > накачали один раз => длина слова увеличилась по крайней мере на m 
   >
   > граница на блоке $a_1$, а вторая заканчивается на $a_k$, они не могут быть одинаковы
   >
   > [   w   \][   $a_1$  \][  $a_k$  ] 
   >
   > ww' = $ux^2 zy^2 v$ противоречие
   >
   > 2) [ \][$a_k$\][$a_1$\][]
   >
   > xzy - посередине $a_k$ и $a_1$	
   >
   > $ux^2 y^2 v$
   >
   > $a_1^l a_k^{l+r} a_1^{l+s} a_k^l$
   >
   > r+s $\le$ m
   >
   > б.о.о. r $\ge$ s
   >
   > r = s => в новом слове первая половина кончается на большее количество $a_k$ -х
   >
   > r > s
   >
   > [$a_1$\][(середина)$a_k^{l+r}$\][]  
   >
   > первая половина нач на $a_1$
   >
   > вторая - на а_k 
   >
   > $a^n b^n c^k , k \ge n$ - не противоречит лемме о накачке, а в Лемме Огдена из-за того, что мы можем что-то выделить нам придется накачать что-то еще

   **Теорема об унарных языках**

   Для языка L $\subseteq$ = {a*} след усл эквивалентны

   1) L - регулярный

   2) L - КСЯ

   3) мн-во длин слов из L - периодическое

   $(M \subseteq \mathbb{N}, если \exists\ n_o, d \in \mathbb{N}:\forall n> n_0  (n\in M) => (n+d \in M))$

   1 => 2 => 3 => 1

   _Д-во_

   > 2) => 3)
   >
   > $\exists n, m\ \forall a^n\ a^{n+r} \in L, r \le m$
   >
   > По лемме о накачке: $a^n = uxzyv = uvzxy$
   >
   > $uvz(xy)^k \in L$
   >
   > Положим $n_o$ = n из леммы о накачке, а d = m! 
   >
   > m! делится на все r $\in$ \{1, ..., m\}
   >
   > $a^{n+lm!} \in L$ - накачать можно сколько угодно раз
   >
   > $\frac{m!}{r}$ 
   >
   > 3 => 1
   >
   > Докажем с помощью построение автомата
   >
   > $\forall i: 0 \le i \le d$ найдем минимальное $k_i \in$ M, $k_i \equiv $ i mod d; k_i > n_0
   >
   > Если для какого-то i $k_i$ не существует, положим его равным 0
   >
   > M - бесконечное => $\exists i: k_i > 0 $
   >
   > k = $\max\limits_i$$\{k_i\}$
   >
   > Строим автомат 
   >
   > ![photo_2019-03-26_11-11-02](.\pics\photo_2019-03-26_11-11-02.jpg)
   >
   > Ручка имеет длину k
   >
   > Обод длины d
   >
   > $\forall$j $\in$ {0,..,k} сост-е $q_j$ закл <=> $a^j \in$ L
   >
   > для остальных $q_s$ - заключительное <=> $a^{s+rd} \in$ L

   ##### Подстановки

   _Опр_ Подстановка $\tau$ : $2^{\Sigma^*}$ -> $2^{\Delta^*}$ ($\Sigma, \Delta$ - алфавиты)

   1) $\tau(\lambda) = \lambda$

   2) $\tau(a) \subseteq \Delta*, a \in \Sigma$

   3) $\tau(a_1, ..., a_n) = \tau(a_1)\tau(a_2)..\tau(a_n)$

   4) $\tau(L_1)  = \bigcup\limits_{w \in L_1}\tau(w)$

   !! Гомоморфизм - частный случай подстановки ($\forall a \in \Sigma, \tau(a) = w \in \Delta^*$)

   \# _Пример_

   Пусть $\Sigma = \{a_1, a_2\}$

   $\tau(a_1) = L_1 \subseteq \Delta^*$

   $\tau(a_2) = L_2 \subseteq \Delta^*$

   $L = \{a_1,a_2\}$ - язык

   $\tau(L) = \tau(a_1) \cup \tau(a_2)  = L_1 \cup L_2$

   L = {a_1a_2}

   $\tau(L) = \tau(a_1)\cdot \tau(a_2) = L_1L_2$

   L = {a_1}*

   $\tau(L) = \tau({a_1}*) = \tau(\bigcup\limits_{i=0}a_1^i) = \bigcup\limits_{i=0}\tau (a_1^i) = \bigcup\limits_{i=0}\tau (a_1)^i = \bigcup\limits_{i=0}L_1^i = L_1^* $

   **Теорема о подстановке**

   Пусть $L \subseteq \Sigma^*$ - КСЯ $\tau: 2^{\Sigma^*} -> 2^{\Delta^*} $- подстановка: $\forall a \in \Sigma \tau(a) $- КСЯ

   Тогда $\tau(L)$ - КСЯ
   _Д-во_

   >L - порожд G = $(\Sigma, \Gamma, P, S)$
   >
   >$\Sigma = \{a_1, ...,a_n\}$
   >
   >$G_i = (\Delta, \Gamma_i, P_i, S_i)\ L(G_i) = \tau(a_i)\ \forall i = \overline{1, n}\ (\Gamma_i \cap \Gamma_j = \empty, j \neq i; \Gamma \cap \Gamma_i = \empty\ \forall i)$в результате применения подстановки к одному символу получили
   >
   >Гр-ка H =$ (\Delta, \bar{\Gamma}, \bar{P}, S) $(аксиомы из грамматики G )
   >
   >$\bar{\Gamma} =\Gamma \cup \bigcup\limits_{i=1}^n \Gamma_i$
   >
   >$\bar{P} = \bigcup\limits_{i=1}^n P_i \cup P'$
   >
   >P' - из P заменой всех терминалов $a_i$ на соотв. $S_i$
   >
   >Нужно предъявить грамматику и доказать, что она порождает
   >
   >Мы предъявили теперь доказываем
   >
   >L(H) = $\tau(L)$
   >
   >1) w $\in$ L(H)
   >
   >![photo_2019-03-26_11-11-05](.\pics\photo_2019-03-26_11-11-05.jpg)
   >
   >Дерево вывода для w 
   >
   >T' - станд. поддерево: все внутр. узлы из $\Gamma$, листья из $\bigcup\limits_{i=1}^n\Gamma_i  \cup \Delta$
   >
   >если $\exists(A \rightarrow \alpha B\beta) \in \bar{P}$
   >
   >$A \in \Gamma; B \notin \Gamma, то\ \alpha, \beta = \lambda$
   >
   >$т.е. S =>^* S_i, ..., S_{i_k} =>_H^* w_{i_1}...w_{i_k} = w;
   >w_{i_j} \in \tau(a_{i_j})$
   >
   >$w = \tau(a_{i_1}) \tau(a_{i_2}) ...  \tau(a_{i_k}) =  \tau(a_{i_1}...a_{i_k}), a_{i_1}...a_{i_k} \in L (т.к.S =>_G^* a_{i_1}...a_{i_k})$
   >
   >$w \in \tau(L)$
   >
   >19.03.19
   >
   >2) $w \in \tau(L)$
   >
   >$\exists u \in L: w \in \tau(u)$
   >
   >$u = a_{i_1}...a_{i_k} => w \in \tau(a_{i_1}...a_{i_k}) = \tau(a_{i_1})...\tau(a_{i_k})$
   >
   >из первой строчки 
   >
   >$S =>_G^+ u = a_{i_1}...a_{i_k} <=> S =>H^+  S_{i_1}...S_{i_k} =>^*  w_{i_1}...w_{i_k};  w_{i_j} \in \tau(a_{i_j})$
   >
   >$w \in L(H)$

   > 19.03.19.

   **Следствие 1**

   Класс КСЯ замкнут относительно регулярных операций(*, $\cdot$, +)

   $\{a_1, a_2\}$ 

   $L_1 = \tau(a_1) $- КСЯ

   $L_2 = \tau(a_2) $- КСЯ

   по теореме подстановки $\tau(\{a_1, a_2\}) = L_1 \cup L_2$

   **Следствие 2**

   Класс КСЯ замкнут относительно перехода к гомоморфным образам 

   (гомоморфизм - частный случай подстановки)

   $\tau(a) \subseteq \Sigma^*$ - подстановка
   
   $\phi(a) \in \Sigma^*$, т.е. $\phi(a) = L, |L|=1$ - гомоморфизм

**Приложение** 

Класс КСЯ не замкнут относительно пересечения и дополнения 

_Д-во_

> возьмем 2 кся и докажем, что их пересеч не кся
>
> $L_1 = \{a^n b^n a^m| n, m \in \mathbb{N_0}\}$ 
>
> $L_2 = \{a^m b^n a^n| n, m \in \mathbb{N_0}\}$
>
> $L_1 = \{a^n b^n| n \in \mathbb{N_0}\} \cdot \{a^*\}$ - КСЯ по сл 1
>
> $L_2 =\{a^*\}  \cdot  \{b^n a^n| n \in \mathbb{N_0}\} $ КСЯ по сл 1
>
> $L_1 \cap L_2 = \{a^n b^n a^n| n \in \mathbb{N_0}\} $ - не КСЯ по лемме о накачке
>
> $L_1 \cap L_2 = \phi(L_3)$
>
> $L_3 = \{a^n b^n c^n| n \in \mathbb{N_0}\}$
>
> $\phi(a) = a, \phi(b) = b, \phi(c) =a$
>
> Для дополнения просто через Де Моргана можно доказать

__Теорема__(о пересечении КСЯ и РЯ)

Пересечения КСЯ с рег. языком - КСЯ

_Д-во_:

> L = L(G), G = ($\Sigma, \Gamma$, P, S) - ксг
>
> A =  ($\Sigma, Q, \delta, q_0$,F), M = L(A) - ря
>
> $L \cap M$
>
> $A_{f_i}$ =($\Sigma, Q, \delta, q_0$,f), f $\in $ F
>
> M =$ \cup_{f_i \in F} L(A_{f_i})$
>
> $L \cap M = L \cap \cup_{f_i \in F} L(A_{f_i}) = \cup_{f_i \in F} L \cap L(A_{f_i})$
>
> => достаточно рассмотреть автомат с одним закл состоянием
>
> $A = (\Sigma, Q, \delta, q_0, f) $
>
> $H = (\Sigma, \bar{\Gamma}, \bar{P}, \bar{S})$
>
> $\bar{\Gamma} = Q x (\Gamma \cup \Sigma) x Q$
>
> $\bar{S} = (q_0, S, f)$
>
> $\bar{P}: 1) если  (A -> X_1,.., X_n) \in P$, то для любого набора состояний $p, q, r_1,..., r_{n-1}$
>
> $(p, A, q) → (p, X_1,r_1)(r_1, X_2, r_2)...(r_{n-1 }X_n q) \in \bar{P}$
>
> первый не имеет отношения к грамматике
>
> 2) если $\delta(p, a) = q, то (p, a, q) → a \in \bar{P}$
>
> L(H) = L $\cap$ M 
>
> $w \in L(H)$
>
> Вывод w: сначала правила вида 1)
>
> пусть w = $a_1...a_n$
>
> $\bar{S} =>_H^* (q_0, a_1, r_1)(r_1, a_2, r_2) ... (r_{n-1}, a_n, f) =>^+ a_1...a_n$
>
> все переходы эквивалентны, то есть по сути мы доказали в обе стороны
>
> $w \in L \cap M$

#### Алгоритм Кока-Янгера-Касами

определить вхождение слова в КСЯ

G = $(\Sigma, \Gamma, P, S) $- в ХНФ

w $\in $ L(G) $\Rightarrow \forall$ i,j; i<j 

$\exists A \in \Gamma$, (A $\rightarrow$ BC) $\in$ P: 

A $\rightarrow$ w[i,..,j]   

B $\rightarrow$ w[i,..,k]   

C $\rightarrow$ w[k+1,..,j]   

i $\le$ k $\le$ j 

Таблица  T (верхнетреуг-я матрица размера nxn |w|=n)

$T_{ij} $- ее клеточки

$T_{ij} = \{A|A \Rightarrow_G^+ w[i,..., i+j-1]\}$ - нетерминалы начиная с позиции i длины j(подслова опред слова)

первый столбец заполняется по правилам вида A $\rightarrow$ a из ХНФ

$T_{ij} = \{A|\exists (A \rightarrow BC) \in P: B \in T_{ik}, C \in T_{(i+k-1,j-k)}\} i \le k < j-1$

Остальные столбцы заполним, перебрав все возможные "распилы" строки на 2 части:

$T_{ij} = \{A | \exists (A \rightarrow BC) \in P, B \in T_{ik}, C \in T_{i+k-1, j-k}, i \le k < j-1 \}$

Если в последней клетке есть аксиома, то w $\in$ L(G)

Если в $T_{ij}$ есть $S$, то в строке есть подстрока, принадлежащая $L(G)$ длины $j$ с позиции $i$

 **Пример**

​	$S → A'A|BB'|SS$

​	$A → A'A|A'D|c$

​	$D → CB'$

​	$B → BB'|A'D|c$

​	$C → A'D|c$

​	$A' → a$

​	$B' → b$

​	$w = aacbcb$

строка - позиция 

столбец - длина

| A'    | -       | S, A    | S,A  | -    | S    |
| ----- | ------- | ------- | ---- | ---- | ---- |
| A'    | S,A     | A, B, C | -    | -    | нет  |
| A,B,C | S, B, D | -       | S    | нет  | нет  |
| B'    | -       | -       | нет  | нет  | нет  |
| A,B,C | S,B,D   | нет     | нет  | нет  | нет  |
| B'    | нет     | нет     | нет  | нет  | нет  |

$w[1,2]=w[1,1]w[2,2]$ — всего один способ поделить на 2 части

$w[1,3]=w[1,1]w[2,3]=w[1,2]w[3,3]$ — можно поделить двумя способами:

- с позиции 1 длины 1 + с позиции 2 длины 2;
- с позиции 1 длины 2 + с позиции 3 длины 1.

**Смысл**: берём значение из ячейки слева ($X$), из ячейки справа ($Y$), и ищем нетерминал ($Z$), из которого выводится последовательность $XY$ ($Z \rightarrow XY$). Если нашли такой терминал, то записываем.

**Сложность**: $n*n$ — таблица, $n$ — распилы и поиск, итого $O(n^3)$

> 26.03.2019

$a^nb^n$ не распознается ДКА

S $\rightarrow $ aSb|$\lambda$

A=($\Sigma$, Q, $\delta, q_0$, F)

|Q| = n

![automata](.\pics\automata.jpg)

#### МП-автоматы

PDA(push-down automaton)

автомат состоит из управляющего устройства у него есть 2 ленты, одна из них потенциально бесконечная

входная лента содержит слово

с входной ленты можно читать, из стека можно читать и туда можно писать (из стека можно читать только вершину)

внизу лежит символ дна, который називается набла $\nabla$

а справа в слове лежит болт (у меня будет решетка #)

![photo_2019-03-26_11-10-59](.\pics\photo_2019-03-26_11-10-59.jpg)

Как происходит один шаг работы автомата

находимя в каком-то состоянии, обозреваем символ входной строки и это один символ, и в стеке один символ и он из алфавита стека

входной

(q, a , B) $\rightarrow (q', \{_, \rightarrow \}, \gamma) - $команды (*)

на основании этой тройки автомат принимает решение,что ему делать

в стек может записываться произвольная цепочка

когда автомат закончил свою работу - оказался в заключительном состоянии и м ыдочитали строку до конца

**_Опр:_** МП - автомат - семерка M = ($\Sigma, \Gamma, Q, \delta, i_o, F, \gamma$)

$\Sigma$ - взодной алфавит

$\Gamma$ - стековый алфавит 

Q - мн-во состояний

$\delta$ - мн-во команд вида (*)

$i_0$ - нач.сост.

F - мн-во закл. сост.

$\gamma \in \Gamma^*$ - нач содерж стека

символ с вершины стека всегда снимается

вместо вершины что-то кладем, возможно 0 символов

МПА обычно представляется в виде таблицы



![photo_2019-03-26_11-16-41](.\pics\photo_2019-03-26_11-16-41.jpg)

Скобочный язык

![photo_2019-03-26_11-24-47](.\pics\photo_2019-03-26_11-24-47.jpg)

√ - команда допуска

(q, #, B) → √ - разбор завершен успешно

в детерминированном одна команда допуска

F = {t}

Q = {q, t}

$\gamma_0 =\lambda$

$i_0 = q$

Г = {(}

![photo_2019-03-26_11-31-31](.\pics\photo_2019-03-26_11-31-31.jpg)

_**Опр:**_ Конфигурация автомата - (снимок его состояния)  - тройка

[q, w, $\gamma$]

q - текущее состояние

w - необработанная часть входной строки

$\gamma$ - текущее содержимое стека

на множестве конфигураций автомата можно ввести отношение возможности перехода из 1-го сост-я в др-е

[q, w, $\gamma$] ╞ [q', q' $\gamma$'] - отношение

пока вершина стека пишется с лева

[q, aw, B$\gamma$] ╞ [q', w, $\gamma', \gamma$] → при выполнении команды (q, a, B) → (q', →, $\gamma'$)

[q, aw, B$\gamma$] ╞ [q', aq, , $\gamma'\gamma$]

(q, a, B) → (q', _, $\gamma'$)

_**Опр:**_МПА распознает цепочку, если он дочитал ее до конца и оказался в закл. состоянии

(вып. команду допуска)

(зак. работу с пустым стеком)

_**Опр:**_ МПА распознает w, если 

[$i_o$, w, $\gamma_0$] ╞* [t, $\lambda$, $\gamma$], t $\in F$ - рефлексивно транзитивное замыкание нашего отношения

$\lambda$ - строка прочитана полностью

L(M) = {w|[$i_o$, w, $\gamma_0$] ╞* [t, $\lambda, \gamma$]}

Построим для языка $a^nb^n$ атомат

![photo_2019-03-26_11-50-26](.\pics\photo_2019-03-26_11-50-26.jpg)

А - b  не была встречена

$\lambda$ - запись пустого слова в стек

пока там лежит А, можно читать а, как только нет, уже только  b и сравнивать

Пример

![photo_2019-03-26_11-55-11](.\pics\photo_2019-03-26_11-55-11.jpg)

> 02.04.19.

#### НМПА и ДМПА

ДМПА 

(q, a, B) $\rightarrow$ (q', {_, →}, $\gamma$)

не более одной команды с такой л.ч.

НМПА

(q, a, B) → 2^(Qx{_,→}xГ*)fin^

__*Теорема*__

Класс языков, распознаваемых НМПА, строга больше класса языков, распознаваемых ДМПА

_Д-во:_

> рассмотрим язык палиндромов четной длины
>
> L = {$w\overleftarrow{w} | w \in \Sigma^*, |\Sigma| \ge 2$}
>
> M = ($\Sigma, \Gamma, \delta, X)$
>
> X - символ, который указывает на то, что не было момента сравнения(середина)
>
> Г = $\Sigma$ x {X}
>
> Сравнение первой половины со второй
>
> автомат угадывает середину, поэтому он может распознать этот язык
>
> Никакой ругой язык он не распознает, потому что у него там в стеке останется еще что-то или наоборот, в стеке не хватит символов в сравнении ![photo_2019-04-02_11-04-40](.\pics\photo_2019-04-02_11-04-40.jpg)
>
> о/п
>
> Предположим, существует ДМПА, распознающий наш язык L.
>
> Работает по принципу сравнения
>
> x $\in \Sigma$
>
> Пусть какое-то слово w $\in \Sigma^*$
>
> $wxx\overleftarrow{w}$  принимается автоматом 
>
> Раз он распознает это слово, значит от сложил в стек wx, а после этого начинает сравнение
>
> Подадим ему на вход $wxxxx\overleftarrow{w}$ 
>
> Из того, что распознается слово $wxx\overleftarrow{w}$, то он к сравнению переходит, когда wx на стеке, он переходит к сравнению и ломается(так как автомат детерменированный)
>
> Нам важно, чтобы на момент перехода к сравнению в стеке было столько же символов, сколько на входе

#### МПА и КСЯ

__*Теорема*__

Любой КСЯ распознается НМПА с одним состоянием и одной командой допуска.

_Д-во:_

> L - КСЯ
>
> G = ($\Sigma$, Г, P, S) - КСГ
>
> L(G) = L
>
> M = ($\Sigma \cup$ {#}, $\Sigma \cup \Gamma \cup \{\nabla\}, \delta, S$)
>
> 1) для любой a $\in \Sigma$ (B, a) → ($\gamma$, _)
>
> $\forall (B, \gamma) \in P$
>
> 2) $\forall a \in \Sigma (a, a) → (\lambda,→)$
>
> 3)($\nabla$, #) → √
>
> L = L(M)?
>
> 1. $w \in L$
>
>    существует левосторонний вывод w в G
>
>    S $\Rightarrow u_1B_1\gamma1 \Rightarrow u_1u_2B_2\gamma_2\Rightarrow ...\Rightarrow u_1u_2...u_{n-1}B_{n-1}\gamma_{n-1}\Rightarrow u_1u_2..u_n$ 
>
>    $\gamma_i \in (\Sigma \cup \Gamma)^*$
>
>    B → $v$
>
>    $u_n = v\gamma_{n-1}$
>
>    Тогда в М реализуема последовательность конфигурация
>
> ​	В начале остаток входной строки это все слово w, а в стеке у нас лежит аксиома
>
> ​	[w, S] = [$u_1,.., u_n$, S] ╞(1) [$u_1,.., u_n, u_1 \beta_1 \gamma_1] ╞^*(2) [u_2, .., u_n, B_1 \gamma_1]$ ╞(1)
>
> ​	$ [u_2, u_n, u_2B_2\gamma_2] ╞^* [u_n, B_{n-1\gamma_{n-1}}] ╞ [u_n, u_n] ╞^*[\lambda, \lambda]$ $\Rightarrow w\in L(M)$ 
>
> 2. $w \in L(M)$
>
>    [w, S]╞^*^ [$\lambda, \lambda$] - конечное число тактов m (тут стрелка на отношение)
>
> ​	 можем представить w так
>
> ​	$w = a_1...a_m$ - закодировали команды, которые применялись на i-м такте
>
> ​	$a_i \in \Sigma \cup\{\lambda\}$
>
> ​	$a_i = \lambda$ - когда на i-м такте применялась команда типа (1)
>
> ​	[w, S] ╞ [$a_1...a_m, S] ╞ [a_1...a_m, a_1...a_{i_1} B_1 \gamma_1]╞^*[a_{i_1+1}...a_m, B_1\gamma_1]╞...╞[\lambda, \lambda]$

__*Лемма*__

Произведение отработанной части входной строки на содержимое стека - левая форма G

>  **Левая форма**  — всё, что может возникнуть в процессе левостороннего вывода.

_Д-во:_

>  Индукция по номеру такта
>
> Б.И.: n = 0	
>
> $\lambda S = S$ - левая форма
>
> Пусть $a_1...a_{n-1} \cdot \gamma_{n-1}$ после n-1 такта и это левая форма по П.И. 
>
> 1) $a_n \in \Sigma \Rightarrow \gamma_{n-1} = a_n\gamma_n$
>
> ​	$B_{n-1} = B_n$
>
> 2) $a_n = \lambda \Rightarrow \gamma_{n-1} = B_{n-1}\gamma_{n-1}'$
>
> ​	$B_{n-1} = a_1...a_{n-1}\gamma\gamma'_{n-1}$ ($B_{n-1}→\gamma) \in $P
>
> ​	$B_{n-1} = a_1...a_{n-1}B_{n-1}\gamma'_{n-1}$ - левая форма

Продолжим доказательство 

>После последнего такта 
>
>$w\cdot\lambda$ - левая форма (по Лемме)
>
>$w \cdot \lambda = w \Rightarrow w\in L(G)$

__*Утверждение*__

Класс КСЯ и класс языков, распознаваемых НМПА, совпадают.

__*Следствие*__

ДМПА распознают собственный подкласс КСЯ.

_Пример:_

S → (S)S|$\lambda$

![photo_2019-04-09_12-18-10](.\pics\photo_2019-04-09_12-18-10.jpg)

> 09.04.19

### Лексический анализ

**Лексема** — элементарная смысловая единица текста. Могут объединяться в классы эквивалентности — **токены**. Описываются токены с помощью **шаблонов**.

> Классы идентификаторов. Одноэлементные классы ключевых слов.

| Токен  | Пример лексемы  | Шаблон                                 |
| ------ | --------------- | -------------------------------------- |
| if     | if              | `if`                                   |
| cop    | <=, >=, ==, …   | `<=?|>=?|[=!]=`                        |
| id     | pi, var23       | `[a-z]\d*`                             |
| number | 1.09, -2.75e-30 | `-?0|[1-9]\d*(.\d{1,})?(e-?[1-9]\d*)?` |

> Первая колонка — имя, которое будет приходить на вход синтаксическому анализатору. comparison operator

#### Распознавание лексем

Вся собранная информация сохраняется в **таблице символов** — структуре данных для хранения информации об идентификаторах.

##### **Буферизация**

|  |  |  |  |  |  |  |  |         |  |  |  |  |  |  |  |  | 
​	   $\uparrow$ 						$\uparrow$
​	*begin*					*current*

*begin* — начало текущей лексемы, протяжённость которой мы пытаемся определить.
*current* — текущий сканируемый символ.

Зачем два буфера? По одному символу может быть невозможно определить, какая перед нами лексема. Если указатель current дошёл до конца одного буфера, то все уже прочитанные символы можно скопировать во второй.

##### **Регистрация токена**

REG — функция, которая точно знает где начался и закончился токен. Делает запись в таблицу символов: какой это был оператор, где он находился в исходном тексте. Нужно для обработчика ошибок.

REG- — до предпоследнего символа.

Токен = <имя, атрибут>. Атрибут — ссылка на запись в таблице символов. Имя используется в лексическом анализе.



**Примеры диаграмм переходов**

![if_else_dka](.\pics\if_else_dka.jpg)

![comaprison_dka](.\pics\comaprison_dka.jpg)

##### **Ошибки**

- несуществующий переход в автомате

##### **Обработка ошибок**

> Не хотим сразу навсегда ломаться, а выдавать все ошибки за раз.

**Режим паники** — пропускаем всё, пока не встретим корректные символы.

Но можно подумать, а может ли префикс оставшийся строки быть преобразован в корректную лексему и сделать что-то из списка:

- пропуск одного символа;
- вставка пропущенного символа;
- замена символа;
- перестановка соседних символов.

### Синтаксический анализ

**Задача** — определить принадлежность слова языку, который задан некоторой КС грамматикой. Грамматика описывает **синтаксис**! Также нужно построить дерево вывода и сообщить об ошибках.

**Типы анализаторов**

- универсальные (алгоритм КЯК);
- нисходящие (восстановление дерева от корня к листьям);
- восходящие.



**Разделённая грамматика**

$\forall A \in \Gamma: (\forall (A \rightarrow \gamma) \in P$ все $\gamma$ начинаются с разных терминалов$)$

> До этого было: $A \rightarrow \gamma$     $\forall a \in Z :(A, a) \rightarrow (\gamma, —)$

> 16.04.19

### Нисходящий анализ

#### Левая рекурсия

Грамматика называется **непосредственно леворекурсивной**, если $\exists (A \rightarrow A \alpha) \in P$. Плохо, потому что грамматика не разделённая. Просто **леворекурсивной**, если $\exists (A \Rightarrow^+ A\alpha)$. 

> Наталкиваясь на такую штуку, мы не можем посчитать, сколько раз было применено такое правило. Потенциальный бесконечный вывод. Но! Существует алгоритм, делающий леворекурсивную грамматику нормальной.

$A \rightarrow A\alpha_1|…|\alpha_n|\beta_1|…|\beta_m$ $\forall i :\beta_i$ не начинается с $A$

$A'$ — новый нетерминал

Заменим все рекурсивные правила на такую группу

$A \rightarrow\beta_1 A'|…|b_m A'$

$A' \rightarrow \alpha_1A'|…|\alpha_n A'|\lambda$

> Левая рекурсия - это накопление альф, и добавление в конце беты. Давайте сначала поставим бету, а потом накопим альфы, перейдя к правой рекурсии.

Но так можно устранить только непосредственную рекурсию! Нужен алгоритм для общего случая.

##### Алгоритм устранения левой рекурсии

> Недостаток — на вход нужно подавать $\lambda$-свободную грамматику. И ацикличную, по Dragon book

Ввод: $\lambda$-свободная грамматика.

Суть: находим правила, где правая часть начинается с предыдущего нетерминала. Заменяем его на то, что из него выводится.

$\Gamma = \{ A_1…A_n\}$

$for \: i=1…n:$
    $for \: j=1…i-1:$  #$j<i$
        Все правила вида $A_i \rightarrow A_j\alpha$ заменить на $A_i\rightarrow \beta \alpha$, где $(A_j \rightarrow \beta) \in P$
    Устранить непосредственную рекурсию для $A_i$

**Доказательство корректности** — индукция по $i$

$(A_i \rightarrow A_j\alpha) \in P \Rightarrow i < j$

**БИ** $i=1$ — устранили непосредственную левую рекурсию из $A_1$ продукций

**ШИ** $A_i \rightarrow A_m\alpha$. m > 1, так как такие продукции мы уже поправили.

Если $\beta$ начинается с нетерминала, то …. ??? 

> Этот нетерминал уже был обработан?

После внутреннего цикла $i \le j$. Равенство — непосредственная рекурсия.

$\blacksquare$

**Пример**

$S \rightarrow Aa|AB|B$

$A \rightarrow SB|ac$

$B \rightarrow Ac|b$

Надо перенумеровать:

$S_1 \rightarrow A_2a|A_2B_3|B_3$

$A_2 \rightarrow S_1B_3|ac$  [зачёркнуто после 2 итерации]

$B_3 \rightarrow A_2c|b$

После внутреннего цикла:

$A_2 \rightarrow A_2a B_3|A_2B_3B_3|B_3B_3|ac$  [зачёркнуто после 2 итерации]

Добавим $A'$:

$A_2 \rightarrow B_3B_3A'|acA'$

$A' \rightarrow aB_3A'|B_3B_3A'|\lambda$

Третья итерация:

$B_3 \rightarrow B_3B_3A'c|acA'c|b$

Устраним непосредственную рекурсию:

$B_3 \rightarrow acA'cB'|bB'$

$B' \rightarrow B_3A'cB'|\lambda$

Готово.



#### Левая факторизация

$A \rightarrow \beta\alpha_1|\beta\alpha_2|…$

**Факторизация** — устранение всех общих префиксов.

**Альтернатива** — все правые части одного нетерминала.

Почему плохо для нисходящего анализа? Из бет выводится одно и то же, и нам нужно пройтись на неопределённую глубину, чтобы понять, какое правило было применено.

> $S \rightarrow if(B)S|if(B)S\: else S$ — не сможем узнать, а был ли else

Для каждого нетерминала, среди его альтернатив, найдём самый длинный общий префикс (необязательно у всех, хотя бы у двух). Затем введём новый нетерминал $A'$.

$A \rightarrow \beta A'$

$A' \rightarrow \alpha_1|\alpha_2$

Продолжаем, пока у альтернатив есть общий префикс.



**Пример**

$S \rightarrow Abc|AbB|AC|ABB$ [зачёркнуто после первой итерации]

$A \rightarrow Bc|b$

$B \rightarrow aa$

$C \rightarrow aA$

Самый длинный общий префикс — Ab

$S \rightarrow AbD|AC|ABB$ [зачёркнуто после второй итерации]

$D \rightarrow c|B$

Самый длинный общий префикс - A

$S \rightarrow AE$

$E \rightarrow bD|C|BB$

Готово.



#### $LL(1)$-грамматики

> [небольшая презентация, pdf](http://gas-teach.narod.ru/au/tfl/tfl08.pdf)

Чего мы хотим? В момент обозревания на стеке какого-то нетерминала и какого-то символа на входе, знать, какую команду нужно применять.

$(B, a) \rightarrow (j, \_)$?

$(B \rightarrow \gamma) \in P$

​       $u$|$v$
$B$
$\beta$    $uB\beta$ — левая форма
$\nabla$

Пусть $v = av'$. Тогда либо из $B$ должно выводиться что-то, начинающееся с $a$, либо, если $B$ аннулируется, тогда из $\beta$ должно выводится что-то, начинающееся с $a$.

###### FIRST

<u>Опр</u>. $FIRST(\alpha) \subseteq \Sigma \cup \{ \lambda\}$: 
$a \in FIRST(\alpha) \iff \alpha \Rightarrow^* a\alpha'$
$\lambda \in  FIRST(\alpha) \iff \alpha \Rightarrow^*  \lambda$

> $FIRST(\alpha)$ — все терминалы, с которых могут начинаться всевозможные выводы из $\alpha$.

> Нисходящий анализ умеет работать с аннулирующими правилами. А с левой рекурсией нет. Поэтому ничего страшного, если в процессе избавления от левой рекурсии появляются аннулирующие правила.

**Пример**

$S \rightarrow AC$

$A \rightarrow abC|bB$

$B \rightarrow b$

$C \rightarrow c|\lambda$

$FIRST(AC) = \{a,b\}$

$FIRST(CA) = \{c,a,b\}$



###### FOLLOW

<u>Опр</u>. $FOLLOW(A) \subseteq \Sigma \cup \{ \dashv \}$: 
$a \in FOLLOW(A) \iff S \Rightarrow^* \alpha A a\beta$
$\dashv \:\in  FOLLOW(A) \iff S \Rightarrow^*  \alpha A$

$FOLLOW(A) = \{c, \dashv\}$

> Множество терминалов, которые могут встретиться непосредственно справа от нетерминала $A$ в некоторой цепочке.



###### SELECT

<u>Опр</u>. $SELECT(A \rightarrow \alpha)$: 

1. $FIRST(\alpha)$, если $\lambda \not \in FIRST(\alpha)$
2. $FIRST(\alpha) \setminus \{\lambda\} \cup FOLLOW(A)$, иначе

> Множество выбора правил.

> $SELECT(A \rightarrow \alpha) = FIRST(\alpha FOLLOW(A))$



###### $LL(1)$-грамматика

<u>Опр</u>. $LL(1)$-грамматика:
$\forall A \in \Gamma : \forall (A \rightarrow \beta), (A \rightarrow \alpha) \in P$:
$SELECT(A \rightarrow \alpha) \cap SELECT (A \rightarrow \beta) = \varnothing$

> LL — две левых стороны. Читаем слева направо, восстанавливаем левый вывод.
>
> 1 — достаточно прочитать один символ со входа, чтобы понять, что делать дальше



**Пример**

$E \rightarrow E+T|T$

$T \rightarrow T*F|F$

$F \rightarrow (E)|x$

Устраним рекурсию

$E \rightarrow TE'$

$E' \rightarrow  +TE'|\lambda$

$T \rightarrow FT'$

$T' \rightarrow *FT'|\lambda$

$F \rightarrow (E)|x$

|      | FOLLOW      |
| ---- | ----------- |
| E    | $\dashv$, ) |
| E'   | $\dashv$, ) |
| T    | +, $\dashv$ |
| T'   |             |
| F    |             |



|           | FIRST     |
| --------- | --------- |
| TE'       | $(, x$    |
| +TE'      | +         |
| $\lambda$ | $\lambda$ |
| FT'       | (, x      |
| *FT'      | *         |
| (E)       | (         |
| x         | $\lambda$ |

> 23.04.19

Если грамматика G содержит леворекурсивное правило, то G - не LL(1)

(A→A$\alpha$) $\in$ P

(A→$\beta$) $\in$ Pб где $\beta[1]\neq A$

select (A→A$\alpha$) $\cap$ selct($\beta \neq \empty$ ?

1) a $\in$ FIRST($\beta$) => $a \in FIRST(A) \subseteq FIRST(A\alpha)$

FIRST(A) = $\bigcup\limits_{A→\beta}FIRST(\beta)$

2) $FIRST(\beta) = {\lambda}$

$select(A→\beta) = FOLLOW(A)$

FOLLOW(A)

2.1)$ a \in FIRST(\alpha) => a \in FOLLOW(A) => a \in select(A→\beta)$

$A => A\alpha => \beta\alpha => \alpha => a \in select(A→A\alpha)$

2.2) $FIRST(\alpha) = {\lambda}$

$select(A→A\alpha)$

$\lambda \in FIRST(A\alpha) => FOLLOW(A) \subseteq select(A→A\alpha)$

$A => A\alpha => \beta\alpha => \alpha => \lambda$

$FOLLOW(A) \subseteq select(A→A\alpha) \cap select(A→\beta)$

#### Алгоритм построения мн-ва FISRT

для символов грамматики​

$G = <\Sigma, \Gamma, P, S>$

$\forall a \in \Sigma: FIRST(a) = \{a\}$

$\forall A...(A → \lambda) \in P: FIRST(A) = \{\lambda\}$

это просто инициализация

пока во множестве first от всех-всех символов не перестанет появляться что-нибудь новое(пока они не стабилизировались)

перебираем все правила вывода

$\forall (A→X_1, ..., X_n) \in P, n > 0$

начиная с первого символа правой части добавить в $FISRT(A) = FISRT(A)\cup(FIRST(X_i)\cap \Sigma)$

(это чтобы лямбда отсекалась, если $\lambda \in FIRST(X_i))$

смотрим, пока очередной $X_i$ можно аннулировать

продолжаем накопление, если i < n 

иначе нужно добавить лямбду в множество FISRT(A) 

#### Алгоритм построения мн-во FOLLOW

> Находим правые части, куда входит данный нетерминал: $B \rightarrow \alpha A\beta$. Сначала надо посмотреть на $FIRST(\beta) \setminus \{\lambda\} \subseteq FOLLOW(A)$. Если $\beta$ аннулируется ($\{\lambda\} \in FIRST(\beta)$): 
>
> $S \Rightarrow^* \gamma_1B\_\gamma_2\_ \Rightarrow \gamma_1\alpha A\beta \_\gamma_2\_ \Rightarrow \gamma_1\alpha A \_\gamma_2\_ $ — $FIRST(\gamma_2) \subseteq FOLLOW(B)$
>
> Подчёркнуты $\gamma_2$

$FOLLOW(a) = \{\dashv \}$

Пока множество FOLLOW не стабилизируется, повторяем:

$\forall (A\rightarrow X_1…X_n) \in P, n > 0$

​	если $(X_n \in \Gamma)$

​		$FOLLOW(X_n) = FOLLOW(X_n) \cup FOLLOW(A)$

​	$i = n - 1;$

​	ann = true; *флаг, что хвост аннулируемый*



​	(*) если $i > 0$ и $X_i \in \Gamma$ и $X_i$ — терминал

​		$FOLLOW(X_i) = FOLLOW(X_{i+1}) \cup (FIRST(X_{i+1}...X_n) \cap \Sigma)$ 

> пересечение нужно, чтобы в FOLLOW не попала $\lambda$

​		если $\lambda \not \in FIRST(X_{i+1})$

​			ann = false 

​		если ann == true и $X_i \in \Gamma$

​			$FOLLOW(X_i) = FOLLOW(X_i) \cup FOLLOW(A)$

​		$i --$; перейти к (*)



**Пример**

$E \rightarrow TE'$

$E' \rightarrow  +TE'|\lambda$

$T \rightarrow FT'$

$T' \rightarrow *FT'|\lambda$

$F \rightarrow (E)|x$

|      | FIRST        | FOLLOW            |
| ---- | ------------ | ----------------- |
| E    | $(, \times$  | $\dashv, )$       |
| E'   | $\lambda, +$ | $\dashv, )$       |
| T    | $(, \times$  | $\dashv, +, )$    |
| T'   | $\lambda, *$ | $\dashv, +, )$    |
| F    | $(, \times$  | $\dashv, +, *, )$ |

> SELECT( ) == FIRST(левая часть) + FOLLOW(правая часть)

#### Построение нисходящего анализатора

по LL(1) - гр-ке

$G = <\Sigma, \Gamma, P, S>$

$M = (\overline{\Sigma}, \overline{\Gamma}, \delta, S) - ДМПА\ расп-й\ L(G)$

$\overline{\Sigma} = \Sigma \cup${#}

$\overline{\Gamma} = \Gamma \cup {\Sigma} \cup {\nabla}$

$\delta:$ 

​	$1) (\nabla$, #) → √​

​	$2) \forall a \in \Sigma (a, a) → (\lambda, →)$

​	3) $\forall A \in \Gamma, \forall(A→\beta) \in P$

$(A, a) \rightarrow (\beta, _)$

$\forall a \in select(A \rightarrow \beta)$

|          | +            | *            | x            | (            | )            | #         |
| -------- | ------------ | ------------ | ------------ | ------------ | ------------ | --------- |
| E        |              |              | TE'          | TE'          |              |           |
| E'       | +TE'         |              |              |              | $\lambda$    | $\lambda$ |
| T        |              |              | FT'          | FT'          |              |           |
| T'       | $\lambda$    | *FT'         |              |              | $\lambda$    | $\lambda$ |
| F        |              |              | x            | (E)          |              |           |
| +        | $\lambda$, → |              |              |              |              |           |
| *        |              | $\lambda$, → |              |              |              |           |
| x        |              |              | $\lambda$, → |              |              |           |
| (        |              |              |              | $\lambda$, → |              |           |
| )        |              |              |              |              | $\lambda$, → |           |
| $\nabla$ |              |              |              |              |              | √         |

![photo_2019-05-28_16-55-13](.\pics\photo_2019-05-28_16-55-13.jpg)

|          | +         | *    | x                      | (                  | )         | #         |
| -------- | --------- | ---- | ---------------------- | ------------------ | --------- | --------- |
| E        |           |      | TE'                    | TE'                |           |           |
| E'       | +TE'      |      |                        |                    | $\lambda$ | $\lambda$ |
| T        |           |      | FT'                    | FT'                |           |           |
| T'       | $\lambda$ | *FT' |                        |                    | $\lambda$ | $\lambda$ |
| F        |           |      | $\lambda, \rightarrow$ | (E), $\rightarrow$ |           |           |
|          |           |      |                        |                    |           |           |
|          |           |      |                        |                    |           |           |
|          |           |      |                        |                    |           |           |
|          |           |      |                        |                    |           |           |
|          |           |      |                        |                    |           |           |
| $\nabla$ |           |      |                        |                    |           | √         |

Замечание 

Если $А \rightarrow \alpha\beta_1|\alpha\beta_2, FIRST(\alpha) \neq {\lambda}$

$select(A \rightarrow \alpha\beta_1) \cap select(A \rightarrow \alpha\beta_2) \neq \empty$

> 07.05.19

#### Обработка синтаксических ошибок

|                                                   | x    | +         | *      | (     | )         | #         |
| :------------------------------------------------ | ---- | --------- | ------ | ----- | --------- | --------- |
| Е - новое подвыражение                            | TE'  | 2.        | 2.     | TE'   | 4.        | 2.        |
| Е' - ожидание оператора и слагаемого              | 1.   | TE', →    |        | 1.    | $\lambda$ | $\lambda$ |
| T - начало операнда                               | FT'  | 2.        | 2.     | FT'   | 4.        | 2.        |
| T' - ожидание оператора и множителя               | 1.   | $\lambda$ | FT', → | 1.    | $\lambda$ | $\lambda$ |
| F - операнд, из него выводится х или подвыражение | →    | 2.        | 2.     | E), → | 4.        | 2.        |
| )                                                 | 3.   | 3.        | 3.     | 3.    | →         | 3.        |
| $\nabla$                                          |      |           |        |       | 4.        | √         |

Ошибка в случае нисходящего анализатора - попадание в пустую клетку таблицы

Либо пытаться снимать со стека, либо пропускать все со входа, пока не будет удача

Снимать со стека - плохой подход, потому что он не сможет работать

##### Типы ошибок в арифметике

1. пропущен оператор
2. пропущен операнд
3. незакрытая (
4. преждевременная )

Как будет обрабатывать?

1. добавить +
2. добавить x
3. добавить (
4. удалить ) из входного потока

Пример

1. )(x+x)(*

   (x+x)+(x*x)

   E$\nabla$

   TE'$\nabla$

   ...

   FT'E'$\nabla$

   E)T'E'$\nabla$

   ...

   T'E'$\nabla$

   E'$\nabla$

   TE'$\nabla$

   FT'E'$\nabla$

   E)T'E'$\nabla$

2. (x+x))(*x

   (x+x) 

   (*x - осталось на входе, а стек пуст

   E$\nabla$

   TE'$\nabla$

   FT'E'$\nabla$

   T'E'$\nabla$

   E'$\nabla$

   $\nabla$

   сломались до конца не дочитали

#### LL(k) - грамматики

_Опр:_ $ w \in FIRST_k(\alpha)$, если $\alpha \Rightarrow^* v$, где 

1) |v| < k, w = v

2) |v| $\ge$ k, |w| = k, w - префикс v

_Опр:_ G - LL(k) - грамматика, если из сущ-я выводов

​	$S \Rightarrow^* wA\alpha \Rightarrow^*wv$

​	$S \Rightarrow^* wA\alpha \Rightarrow w\gamma\alpha \Rightarrow wu$

где $FIRST_k(u) = FIRST_k(v)$

следует, что $\beta = \gamma$

Класс грамматик 

LL(1) $\sub$ LL(2) $\sub$ .. $\sub$ LL(k) $\sub$ LL(k+1)...

Пример

$S \rightarrow a^kb|a^kc$ - LL(k+1), но не LL(k)

$S \rightarrow$ abA|$\lambda$

$A \rightarrow Saa|b$

_Пример_

не LL(1):

FOLLOW(S) = {a, #}

SELECT(S → abA) $\cap$ SELECT(S→$\lambda$) = {a}

Аксимома на вершине стека бывает в 2-х случаях: либо в самом начале, либо мы можем понять, что потом добавлено

LL язык - язык, для которого существует какая-то LL(k) рамматика

не LL языки тоже существуют

Пример

$\{a^k0b^k\}\cup\{a^k1b^{2k}\}$ - не LL язык

##### Универсальный метод рекурсивного спуска

Если для любой цепочки существует число, которое ограничивает длину вывода, то можно эмулировать работу автомата

Идем по поддеревьям, если что-то не так, то идем сначала влево, а потом в самое начало

_Пример_:

$S \rightarrow aSbS|aS|c$

aacbc

> 14.05.19.

#### Восходящий синтаксический анализ

Будем рассматривать:

Приведенные, однозначные, $\lambda$ - свободные, обратимые

Обратимая -  у одинаковых правых нет разных левых

r-форма(правая форма)

_Опр:_  Основа $\beta$ r-формы $\gamma$: $\gamma=\alpha\beta v, \exists (A→B) \in P$

Другими словами: $S \Rightarrow^* \alpha Av \Rightarrow \alpha\beta v \Rightarrow ...$

Вывод (правосторонний): ($\alpha_1=S, ... \alpha_n=w$)

Основа r-формы $\alpha_{i+1}:$ 

$\alpha_i = \alpha Av $

$\alpha_{i+1} = \alpha\beta v$

_Пример:_

​	S → aSAb|c

​	A → Ab|b

​	w = acbbb

Построим для этой цепочки дерево восходящим образом. Пока что нам основы будут подсказывать. Переносим все символы в стек, пока не найдём основу. Потом сворачиваем её к её нетерминалу и продолжаем.

1. $a$
2. $ac$: c соответствует основе. Уберём её, заменив на левую часть $\rightarrow aS$
3. $aSb \rightarrow aSA$
4. $aSAb$: тут на основу претендуют 3 цепочки. Но мы знаем, что лучше использовать $Ab$ $ \rightarrow aSA$
5. $aSAb \rightarrow S$

Дерево вывода:

```
    S
  //| \
/ /  \ \  
| |   A \
| |  / \ \
| S  A  | |
| |  |  | |
a c  b  b b 
```

##### Технология "Перенос-свертка"

Если есть основа, то происходит свертка, если нет, то перенос

Индикатор завершения - в стеке только аксиома, а цепочка дочитана до конца

_Опр:_ Куст К в дереве Т - поддерево высоты 1 такое, что

​	1) все его листья являются листьями в исходном дереве;

​	2) у корня К все сыновья в Т - листья в К.

Свертка - обрезание куста(смерджить листья в родительскую вершину)

Двигаемся слева направо и сворачиваем каждый раз самое левое, поэтому вывод получается правосторонний

Восстанавливаем вывод с помощью нашего метода:

S$\Rightarrow aSAb \Rightarrow aSAbb \Rightarrow aSbbb \Rightarrow acbbb$

При использовании этой технологии, у нас всегда сохраняется инвариантность: 

​	Произведение содержимого стека на необработанную часть входной строки - r-форма

В начале стек пуст!

**_Предложение:_**

При использовании технологии "Перенос-свертка" в любой момент времени правый конец основы находится на вершине стека, либо еще не перенесен в стек.

_Д-во:_

> (1) $S \Rightarrow^* \alpha Av_1 B v_2 \overset{1}\Rightarrow \alpha Av_1uv_2 \overset{2}\Rightarrow \alpha \gamma v_1 u v_2$
>
> В форме было 2 разделённых нетерминала, мы применили правило. Значит, всё, что было после правого нетерминала стало терминалами, иначе он бы не был самым правым. 
>
> (2) $S \Rightarrow ^* \alpha A v \overset{1}\Rightarrow \alpha\beta B uv \overset{2}\Rightarrow \alpha\beta \gamma uv$
>
> Из правого нетерминала получается что-то, содержащее нетерминал. Тогда он тоже самый правый и следующее правило применяется к нему. 
>
> **БИ** Первый раз, когда делается свёртка, основа наверху просто по алгоритму.
>
> 1. Свернули \gamma к A
>
>    Перед свёрткой, по ПИ всё ок:  			  После свёртки:
>    		 $v_1 u v_2$ 														$v_1 u v_2$ 
>    $\gamma$			  				 								   $A$
>    $\alpha$							  									$\alpha$			
>    $\nabla$ 						 	  					  	       $\nabla$
>
> 2. 
>
>    Перед свёрткой, по ПИ всё ок:  			  После свёртки:
>    		 $u v$ 																$u v$ 
>    $\gamma$			  				 								   $B$
>    $\beta$							  									$\beta$		
>    $\alpha	$											 		      	   $\alpha$
>    $\nabla$ 						 	  					  	       $\nabla$
>
> $\blacksquare$

#### Способы определения основы

##### Анализ на основе отношений предшествования

Рассматриваем:

ацикличные, обратимые, $\lambda$ - свободные грамматики

Отношения на ($\Sigma \cup \Gamma)^2$

1. $\overset{\cdot}=$

   X $\overset{\cdot}=Y$ если XY - подслово основы некоторой r-формы

2. <$\cdot$ 

   X <$\cdot$ Y, если $\exists$ r-форма, ее основа начинается с Y, перед ней находится X 

3. $\cdot$>

   X $\cdot$> Y, если $\exists$ r-форма, ее основа заканчивается на Х, за ней находится Y

   ![photo_2019-05-28_17-15-12](.\pics\photo_2019-05-28_17-15-12.jpg)

_Предложение:_ 

​	1) X $\overset{\cdot}=$ Y <=> $\exists (A \rightarrow \alpha XY\beta) \in P$

​	2) X <$\cdot$ Y <=> $\exists (A \rightarrow \alpha XZ\beta) \in P$

​		Z $\Rightarrow^+ Y\gamma$

​	3)  X $\cdot$> Y <=> $Y \in \Sigma, \exists (A \rightarrow \alpha Z_1Z_2\beta)\in P,$

​		$Z_1 \Rightarrow^+ \gamma_1X, Z_2 \Rightarrow^* Y\gamma$

​	![presc_1](.\pics\presc_1.jpg)

_Замечание:_ 

​	FIRST'(X) - символы, выводящиеся на первом месте из Х (за 1 и более шагов)

​	LAST'(X) - символы, выводящиеся на последнем месте из Х (за 1 или более шагов)

_Предложение в форме FIRST' и LAST':_

​	Для отношения больше: Y - только терминалы

​	1) X $\overset{\cdot}=$ Y <=> $\exists (A \rightarrow \alpha XY\beta) \in P$

​	2) X <$\cdot$ Y <=> $\exists (A \rightarrow \alpha XZ\beta) \in P$

​		$Y \in FIRST'$(Z)

​	3)  X $\cdot$> Y <=> $Y \in \Sigma, \exists (A \rightarrow \alpha Z_1Z_2\beta)\in P,$

​		$X \in LAST'(Z_1), Y \in \Sigma, Y = Z_2 или Y \in FIRST'(Z_2)$

_Пример:_

​	S → aSAb|c

​	A → Ab|b

​	$\vdash, \dashv$

​	$\vdash \lessdot X$, если c Х начинается r-форма 

​	$X \gtrdot \dashv$, если на Х заканчивается r-форма

​	

|          | S                  | A                            | a          | b                  | c          | $\dashv$  |
| -------- | ------------------ | ---------------------------- | ---------- | ------------------ | ---------- | --------- |
| S        |                    | $\lessdot, \overset{\cdot}=$ |            | $\lessdot $        |            | $\gtrdot$ |
| A        |                    |                              |            | $\overset{\cdot}=$ |            |           |
| a        | $\overset{\cdot}=$ |                              | $\lessdot$ |                    | $\lessdot$ |           |
| b        |                    | $\gtrdot$                    |            | $\gtrdot$          |            | $\gtrdot$ |
| c        |                    | $\gtrdot$                    |            | $\gtrdot$          |            | $\gtrdot$ |
| $\vdash$ | $\lessdot$         |                              | $\lessdot$ |                    | $\lessdot$ |           |

|      | FIRST' | LAST' |
| ---- | ------ | ----- |
| S    | a, c   | b, c  |
| A    | A, b   | b     |

С тем, что выводится из соседа первым, X будет в отношении меньше

Чтобы построить $\gtrdot$ нам нужно рассмотреть пары, в которых на первом месте нетерминалов



> 21.05.2019

_Опр:_ G - грамматика простого предшествования, если она ациклична,  обратима и для любой пары символов в G выполнено не более одного отношения предшествования.

_Предложение:_ Пусть G - грамматика простого предшествования, $\vdash \gamma \dashv = x_0x_1...x_nx_{n+1}$ - ее r-форма.

Тогда $x_k,...x_l$ - основа этой формы, если $x_l$  $\gtrdot x_{l+1}$ и l - минимальное с таким св-м $x_{k-1} \lessdot x_k, x_k \doteq x_{k+1} \doteq ... \doteq x_l$

> Д-во:
>
> $\vdash \gamma \dashv$ - r форма, $x_s..x_t $- ее основа
>
> $x_t \gtrdot x_{t+1}$ по опр => $t \ge l$, 
>
> о.п.(Предполагаем, что есть кандидат на основу правее, чем текущая. Но это не так - у r-формы основа это самый левый куст.)
>
> 1) s>l 
>
> $x_s..x_t$ - соответсвуют самому левому куст
>
> 2) $x_l \gtrdot x_{l+1}$ => не имеет правых братьев
>
> Среди левых братьев $x_l$ есть внутренний узел.
>
> ![osnova](.\pics\osnova.jpg)

***Пример***

$S \rightarrow aSSb|c$

|          | S                  | a          | b                  | c          | $\dashv$  |
| -------- | ------------------ | ---------- | ------------------ | ---------- | --------- |
| S        | $\overset{\cdot}=$ | $\lessdot$ | $\overset{\cdot}=$ | $\lessdot$ | $\gtrdot$ |
| a        | $\overset{\cdot}=$ | $\lessdot$ |                    | $\lessdot$ |           |
| b        |                    | $\gtrdot$  | $\gtrdot$          | $\gtrdot$  | $\gtrdot$ |
| c        |                    | $\gtrdot$  | $\gtrdot$          | $\gtrdot$  | $\gtrdot$ |
| $\vdash$ | $\lessdot$         | $\lessdot$ |                    | $\lessdot$ |           |

FIRST'(S) = {a,c}

LAST'(S) = {b, c}

$\vdash acaccbb \dashv $

$\vdash acaccbb \dashv $

$\nabla \vdash \lessdot a \lessdot$

<u>тут пропущено</u>

> 28.05.19.

#### Отношения операторного предшествования

Операторная грамматика(двух нетерминалов подряд в правой части не встречается)

_Пример_

E → E+E|E*E|(E)|x

_Замечание:_

Как определять основы?

Если цепочка aEb входит в r-форму и ровно один из терминалов a, b принадлежит основе, то и E принадлежит основе.

Это следует из того, что не только в правых частях не может быть двух соседних нетерминалов, но и в ее r-форме.

Как определить края основы? 

Найти самое левое больше и ближайшее к нему меньшее, то что между ними - основа и вот как в предыдущем замечании края определяем.

$a \lessdot b$ - a имеет меньший приоритет

$a \overset{\cdot}= b$ - a и b сворачиваются одновременно

$a \gtrdot b$ -  a имеет больший приоритет

$\vdash \lessdot a$ - с а может начинаться r-форма

$a \gtrdot \dashv$ - на а может заканчиваться r-форма

Правила: 

Операнды сворачиваются раньше всех

Операторы имеющие больший приоритет сворачиваются раньше, чем имеющие меньший приоритет

Между одинаковыми: если лево-ассоциативный, то левый, если право-ассоциативный, то правый.

Унарные сворачиваются раньше всех.

Выражение в скобках раньше выражения вне скобок.

Отношения строятся только между нетерминалами.

Пример: 

E → E+E|E*E|(E)|-E|min(E, E)|x

|          | x          | (                  | )                  | -          | +          | *          | min        | ;                  | $\dashv$  |
| -------- | ---------- | ------------------ | ------------------ | ---------- | ---------- | ---------- | ---------- | ------------------ | --------- |
| x        |            |                    | $\gtrdot$          |            | $\gtrdot$  | $\gtrdot$  |            | $\gtrdot$          | $\gtrdot$ |
| (        | $\lessdot$ | $\lessdot$         | $\overset{\cdot}=$ | $\lessdot$ | $\lessdot$ | $\lessdot$ | $\lessdot$ | $\overset{\cdot}=$ |           |
| )        |            |                    | $\gtrdot$          |            | $\gtrdot$  | $\gtrdot$  |            | $\gtrdot$          | $\gtrdot$ |
| -        | $\lessdot$ | $\lessdot$         | $\gtrdot$          | $\lessdot$ | $\gtrdot$  | $\gtrdot$  | $\lessdot$ | $\gtrdot$          | $\gtrdot$ |
| +        | $\lessdot$ | $\lessdot$         | $\gtrdot$          | $\lessdot$ | $\gtrdot$  | $\lessdot$ | $\lessdot$ | $\gtrdot$          | $\gtrdot$ |
| *        | $\lessdot$ | $\lessdot$         | $\gtrdot$          | $\lessdot$ | $\gtrdot$  | $\gtrdot$  | $\lessdot$ | $\gtrdot$          | $\gtrdot$ |
| min      |            | $\overset{\cdot}=$ |                    |            |            |            |            |                    |           |
| ;        | $\lessdot$ | $\lessdot$         | $\overset{\cdot}=$ | $\lessdot$ | $\lessdot$ | $\lessdot$ | $\lessdot$ |                    |           |
| $\dashv$ | $\lessdot$ | $\lessdot$         |                    | $\lessdot$ | $\lessdot$ | $\lessdot$ | $\lessdot$ |                    |           |

x * -min(x; x+x)

$\vdash \lessdot x \gtrdot$

$\vdash_E \lessdot * \lessdot - \lessdot min \overset{\cdot}= ( \lessdot x \gtrdot)$

$\vdash_E \lessdot * \lessdot - \lessdot min \overset{\cdot}= (_E \overset{\cdot}= ;_E \lessdot +_E \gtrdot$

Что включить в основу

Видим в стеке 2 нетерминала , берем их в основу

$\vdash_E \lessdot * \lessdot - \lessdot min \overset{\cdot}= (_E \overset{\cdot}= ;_E \overset{\cdot}=) \gtrdot$

$\vdash_E \lessdot * \lessdot -_E \gtrdot$

$\vdash_E \lessdot *_E \gtrdot$

$\vdash_E \dashv$

Таблица не так и нужна, достаточно иметь 2 функции.

Каждому терминалу поставим в соответсиве 2 числа $a \in \Sigma$ l(a)$\in N$ - слева, r(a)$\in N$ - справа 

l(a) < r(b), если a $\lessdot b$

l(a) = r(b), если $a \overset{\cdot}= b$

l(a) > r(b), если $a \gtrdot b$

Нужно построить двудольный граф

$l_a → r_b$, если l(a) > r(b)

$r_b → l_a$, если l(a) < r(b)

если в графе не оказалось циклов, то нужно взять самый длинный путь.

